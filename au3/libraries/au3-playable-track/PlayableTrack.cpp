/*!********************************************************************

  Audacity: A Digital Audio Editor

  PlayableTrack.cpp

  Dominic Mazzoni

  Paul Licameli split from Track.cpp

*******************************************************************//**

\class AudioTrack
\brief A Track that can load/save audio data to/from XML.

\class PlayableTrack
\brief An AudioTrack that can be played and stopped.

*//*******************************************************************/
#include "PlayableTrack.h"
#include <wx/utils.h>

namespace {
// Helper for ID generation
static std::atomic<int64_t> sNextPersistentId { 1000 }; // Start high to avoid potential conflicts

int64_t NewPersistentID() {
    return sNextPersistentId.fetch_add(1, std::memory_order_relaxed);
}

struct PlayableTrackState : ClientData::Cloneable<> {
    PlayableTrackState() {
        mPersistentId.store(NewPersistentID(), std::memory_order_relaxed);
    }
    PlayableTrackState(const PlayableTrackState& other);
    PlayableTrackState& operator=(const PlayableTrackState&) = delete;
    ~PlayableTrackState() override;
    std::unique_ptr<ClientData::Cloneable<> > Clone() const override;

    static PlayableTrackState& Get(PlayableTrack& track);
    static const PlayableTrackState& Get(const PlayableTrack& track);

    bool GetMute() const;
    void SetMute(bool value);
    bool GetSolo() const;
    void SetSolo(bool value);

    int64_t GetPersistentId() const;
    void SetPersistentId(int64_t value);

    int64_t GetRouteId() const;
    void SetRouteId(int64_t value);

private:
    //! Atomic because it may be read by worker threads in playback
    std::atomic<bool> mMute{ false };
    //! Atomic because it may be read by worker threads in playback
    std::atomic<bool> mSolo{ false };

    std::atomic<int64_t> mPersistentId{ 0 };
    std::atomic<int64_t> mRouteId{ PlayableTrack::MasterRouteId };
};

static const ChannelGroup::Attachments::RegisteredFactory
    stateFactory{ [](auto&) { return std::make_unique<PlayableTrackState>(); } };

//! Copy can't be generated by default because of mutable members
PlayableTrackState::PlayableTrackState(const PlayableTrackState& other)
{
    SetMute(other.GetMute());
    SetSolo(other.GetSolo());
    // Copy the ID? Usually clone gets a new ID, but if it's a "Clone" for playback (duplicate),
    // it should probably keep the ID if it's representing the same track logic?
    // Wait, Duplicate() creates a new track.
    // If we copy-paste, we probably want a new ID.
    // If we undo/redo (Shallow copy), we share the attachment? No, attachments are copied.
    // Track::Duplicate calls Clone().
    // If we duplicate a track, should it have the same persistent ID?
    // If it has the same ID, routing to "ID X" will send to both tracks?
    // Audacity usually doesn't support 1-to-many routing destination ambiguity easily.
    // So new track -> new ID.
    // But `Clone` is also used for Undo history states. Undo state should have SAME ID.
    // Track::Clone(bool backup).
    // The attachment factory doesn't know if it's backup or not.
    // However, `Track::CopyAttachments` handles deep vs shallow.
    // If deep copy (Duplicate), we get here.
    // If we are duplicating, we probably want a NEW ID to avoid routing conflicts.
    // But if we are snapshotting for Undo, we want the SAME ID.
    // ClientData::Cloneable::Clone() is used for Deep Copy.

    // For now, let's generate a NEW ID for safety on duplication,
    // unless we strictly manage it from outside.
    // But for Undo, we rely on Shallow Copy usually?
    // Audacity Undo system copies tracks.
    // If `PlayableTrackState` is Deep Copied, it means it's a new instance.
    // If I give it a new ID, Undo will break references?
    // Actually, `ClientData::DeepCopying` is the policy.
    // Track::Duplicate(backup=true) -> Shallow Copy?
    // Track::Duplicate default -> Clone().

    // Let's preserve ID on clone. If user wants unique ID (Duplicate), they should reset it.
    // But `Track::Duplicate` doesn't know about this field.
    // I'll preserve it.
    mPersistentId.store(other.GetPersistentId(), std::memory_order_relaxed);
    mRouteId.store(other.GetRouteId(), std::memory_order_relaxed);
}

PlayableTrackState::~PlayableTrackState() = default;

std::unique_ptr<ClientData::Cloneable<> > PlayableTrackState::Clone() const
{
    return std::make_unique<PlayableTrackState>(*this);
}

PlayableTrackState& PlayableTrackState::Get(PlayableTrack& track)
{
    return track.Attachments::Get<PlayableTrackState>(stateFactory);
}

const PlayableTrackState& PlayableTrackState::Get(const PlayableTrack& track)
{
    return Get(const_cast<PlayableTrack&>(track));
}

bool PlayableTrackState::GetMute() const
{
    return mMute.load(std::memory_order_relaxed);
}

void PlayableTrackState::SetMute(bool value)
{
    mMute.store(value, std::memory_order_relaxed);
}

bool PlayableTrackState::GetSolo() const
{
    return mSolo.load(std::memory_order_relaxed);
}

void PlayableTrackState::SetSolo(bool value)
{
    mSolo.store(value, std::memory_order_relaxed);
}

int64_t PlayableTrackState::GetPersistentId() const
{
    return mPersistentId.load(std::memory_order_relaxed);
}

void PlayableTrackState::SetPersistentId(int64_t value)
{
    mPersistentId.store(value, std::memory_order_relaxed);
}

int64_t PlayableTrackState::GetRouteId() const
{
    return mRouteId.load(std::memory_order_relaxed);
}

void PlayableTrackState::SetRouteId(int64_t value)
{
    mRouteId.store(value, std::memory_order_relaxed);
}

}

AudioTrack::AudioTrack()
    : Track{}
{
}

AudioTrack::AudioTrack(const Track& orig, ProtectedCreationArg&& a)
    : Track{orig, std::move(a)}
{
}

PlayableTrack::PlayableTrack()
    : AudioTrack{}
{
}

PlayableTrack::PlayableTrack(
    const PlayableTrack& orig, ProtectedCreationArg&& a)
    : AudioTrack{orig, std::move(a)}
{
}

void PlayableTrack::SetMute(bool m)
{
    if (DoGetMute() != m) {
        DoSetMute(m);
        Notify(true);
    }
}

void PlayableTrack::SetSolo(bool s)
{
    if (DoGetSolo() != s) {
        DoSetSolo(s);
        Notify(true);
    }
}

void PlayableTrack::SetPersistentId(int64_t id)
{
    DoSetPersistentId(id);
}

void PlayableTrack::SetRouteId(int64_t id)
{
    DoSetRouteId(id);
}

bool PlayableTrack::DoGetMute() const
{
    return PlayableTrackState::Get(*this).GetMute();
}

void PlayableTrack::DoSetMute(bool value)
{
    PlayableTrackState::Get(*this).SetMute(value);
}

bool PlayableTrack::DoGetSolo() const
{
    return PlayableTrackState::Get(*this).GetSolo();
}

void PlayableTrack::DoSetSolo(bool value)
{
    PlayableTrackState::Get(*this).SetSolo(value);
}

int64_t PlayableTrack::DoGetPersistentId() const
{
    return PlayableTrackState::Get(*this).GetPersistentId();
}

void PlayableTrack::DoSetPersistentId(int64_t id)
{
    PlayableTrackState::Get(*this).SetPersistentId(id);
}

int64_t PlayableTrack::DoGetRouteId() const
{
    return PlayableTrackState::Get(*this).GetRouteId();
}

void PlayableTrack::DoSetRouteId(int64_t id)
{
    PlayableTrackState::Get(*this).SetRouteId(id);
}

// Serialize, not with tags of its own, but as attributes within a tag.
void PlayableTrack::WriteXMLAttributes(XMLWriter& xmlFile) const
{
    xmlFile.WriteAttr(wxT("mute"), DoGetMute());
    xmlFile.WriteAttr(wxT("solo"), DoGetSolo());
    xmlFile.WriteAttr(wxT("id"), DoGetPersistentId());

    int64_t routeId = DoGetRouteId();
    if (routeId != MasterRouteId) {
        xmlFile.WriteAttr(wxT("route_to"), routeId);
    }

    AudioTrack::WriteXMLAttributes(xmlFile);
}

// Return true iff the attribute is recognized.
bool PlayableTrack::HandleXMLAttribute(const std::string_view& attr, const XMLAttributeValueView& value)
{
    long nValue;
    // For 64-bit values we might need long long
    long long llValue;

    if (attr == "mute" && value.TryGet(nValue)) {
        DoSetMute(nValue != 0);
        return true;
    } else if (attr == "solo" && value.TryGet(nValue)) {
        DoSetSolo(nValue != 0);
        return true;
    } else if (attr == "id" && value.TryGet(llValue)) {
        DoSetPersistentId(llValue);
        // Ensure our generator is ahead of any loaded ID
        // Note: sNextPersistentId is static, this might race if loading multiple files?
        // But loading is usually serial.
        // Also, strictly speaking, we should atomic_max update.
        int64_t next = sNextPersistentId.load(std::memory_order_relaxed);
        while (next <= llValue && !sNextPersistentId.compare_exchange_weak(next, llValue + 1)) {
            // spin
        }
        return true;
    } else if (attr == "route_to" && value.TryGet(llValue)) {
        DoSetRouteId(llValue);
        return true;
    }

    return AudioTrack::HandleXMLAttribute(attr, value);
}

auto AudioTrack::ClassTypeInfo() -> const TypeInfo&
{
    static Track::TypeInfo info{
        { "audio", "audio", XO("Audio Track") },
        false, &Track::ClassTypeInfo() };
    return info;
}

auto PlayableTrack::ClassTypeInfo() -> const TypeInfo&
{
    static Track::TypeInfo info{
        { "playable", "playable", XO("Playable Track") },
        false, &AudioTrack::ClassTypeInfo() };
    return info;
}

EnumSetting<SoloBehavior> TracksBehaviorsSolo{
    wxT("/GUI/Solo"),
    {
        ByColumns,
        { XO("Multi-track"), XO("Simple") },
        { wxT("Multi"),     wxT("Simple") }
    },
    0, // "Multi-track"
    { SoloBehaviorMulti, SoloBehaviorSimple },
};
